# ********RoostGPT********
"""
Test generated by RoostGPT for test python-unit-test using AI Type  and AI Model 

ROOST_METHOD_HASH=play_game_b8b2e98046
ROOST_METHOD_SIG_HASH=play_game_657e8701f2


Scenario 1: Testing game progress when Player 1 is batting and Player 2 is bowling.
Details:
  TestName: test_game_progress_player1_batting_player2_bowling
  Description: The test verifies if the game progresses correctly when Player 1 is batting, and Player 2 is bowling. It checks each over's summary and final player scores.
Execution:
  Arrange: Initialize choices for Player 1 and Player 2 as batting and bowling respectively. Initialize number of overs.
  Act: Invoke the function 'play_game' with the chosen parameters.
  Assert: Check if the scores for Player 1 and Player 2 are calculated correctly, and verify if the summary of each over is accurate.
Validation:
  Rationale: This test scenario validates the main logic of the game, ensuring that games with different choices of batting and bowling progress as expected.

Scenario 2: Testing game progress when Player 2 is batting and Player 1 is bowling.
Details:
  TestName: test_game_progress_player2_batting_player1_bowling
  Description: The test verifies if the game progresses correctly when Player 2 is batting, and Player 1 is bowling. It checks each over's summary and the final player scores.
Execution:
  Arrange: Initialize choices for Player 2 and Player 1 as batting and bowling respectively. Initialize the number of overs.
  Act: Invoke the function 'play_game' with the chosen parameters.
  Assert: Check if the scores for Player 2 and Player 1 are calculated correctly, and verify if the summary of each over is accurate.
Validation:
  Rationale: This tests the game's flexibility to allow either player to bat or bowl, ensuring that the game's business logic functions correctly under a variety of configurations.

Scenario 3: Testing the function behavior when the difficulty level is set to 1.
Details:
  TestName: test_play_game_difficulty_level_1
  Description: This test verifies the correct functioning of the game with a specified difficulty level.
Execution:
  Arrange: Define the number of overs and the choices of Player 1 and Player 2. Set the difficulty level to 1.
  Act: Call the function 'play_game' with specified parameters.
  Assert: Check if the difficulty level is factorized into the gameplay, affecting the player's scores accurately.
Validation:
  Rationale: The importance of this test is to ensure that the difficulty level parameter impacts the game appropriately, ensuring an increase in difficulty level indeed makes the game harder to score.

Scenario 4: Test the result when all the overs have been played.
Details:
  TestName: test_play_game_all_overs_played
  Description: The test verifies the function's serviceability to go through all the overs without errors and compute the final result accurately.
Execution:
  Arrange: Initialize the overs, player1_choice, player2_choice, and difficulty parameter.
  Act: Invoke the function 'play_game' with the initialized parameters.
  Assert: Ensure there are no errors and total scores for each player are correct after all the overs have been played.
Validation:
  Rationale: This test case is important to validate that the game's primary logic functions well over the entire course of a match, giving accurate results at the end.

"""

# ********RoostGPT********
import random
import time
import pytest
from HandCricket.main import play_game

class Test_MainPlayGame:

    @pytest.mark.regression
    def test_game_progress_player1_batting_player2_bowling(self):
        overs = 2
        player1_choice = "1"
        player2_choice = "2"
        player1_score, player2_score = play_game(overs, player1_choice, player2_choice)
        assert isinstance(player1_score, int), "Player 1 score must be an integer"
        assert isinstance(player2_score, int), "Player 2 score must be an integer"
        assert 0 <= player1_score <= overs*6*10, "Player 1 score must be within expected boundaries"
        assert 0 <= player2_score <= overs*6*10, "Player 2 score must be within expected boundaries"

    @pytest.mark.regression
    def test_game_progress_player2_batting_player1_bowling(self):
        overs = 2
        player1_choice = "2"
        player2_choice = "1"
        player1_score, player2_score = play_game(overs, player1_choice, player2_choice)
        assert isinstance(player1_score, int), "Player 1 score must be an integer"
        assert isinstance(player2_score, int), "Player 2 score must be an integer"
        assert 0 <= player1_score <= overs*6*10, "Player 1 score must be within expected boundaries"
        assert 0 <= player2_score <= overs*6*10, "Player 2 score must be within expected boundaries"

    @pytest.mark.regression
    def test_play_game_difficulty_level_1(self):
        overs = 2
        player1_choice = "1"
        player2_choice = "2"
        difficulty = 1
        player1_score, player2_score = play_game(overs, player1_choice, player2_choice, difficulty)
        assert isinstance(player1_score, int), "Player 1 score must be an integer"
        assert isinstance(player2_score, int), "Player 2 score must be an integer"
        assert 0 <= player1_score <= overs*6*10, "Player 1 score must be within expected boundaries"
        assert 0 <= player2_score <= overs*6*10, "Player 2 score must be within expected boundaries"

    @pytest.mark.regression
    def test_play_game_all_overs_played(self):
        overs = 5
        player1_choice = "1"
        player2_choice = "2"
        player1_score, player2_score = play_game(overs, player1_choice, player2_choice)
        assert isinstance(player1_score, int), "Player 1 score must be an integer"
        assert isinstance(player2_score, int), "Player 2 score must be an integer"
        assert 0 <= player1_score <= overs*6*10, "Player 1 score must be within expected boundaries"
        assert 0 <= player2_score <= overs*6*10, "Player 2 score must be within expected boundaries"
